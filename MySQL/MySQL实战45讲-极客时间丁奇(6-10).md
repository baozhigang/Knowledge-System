# 《MySQL实战45讲》— 极客时间丁奇(6-10) 专栏总结

### 06 全局锁和表锁
    1）MySQL的锁可分为：全局锁、表级锁、行锁
    2）全局表主要用在逻辑备份过程中，对于全部是InnoDB引擎的库，single-transaction 可重复读，对应用更友好
    3）表锁一般是数据库引擎不支持行锁的时候才会被用到
    4）在MySQL5.5版本中添加了MDL，对一个表增删改查的时候添加读锁（只读），修改表结构的时候，添加写锁
    5）MDL直到事务提交才释放

### 07 行锁功过
    1）两阶段锁协议：
        在InnoDB事务中，行锁是在需要的时候才加上的，而并不是不需要了就立刻释放。而是在整个事务完成后才释放
        所以在事务中，要把最容易造成冲突的，最容易影响并发的锁的放到最后
    2）死锁和死锁检测
        innodb_deadlock_detect  = on  主动开启死锁检测。死锁检测比较耗内存，所以要控制好并发

### 08 事务到底是隔离的还是不隔离的
    1)InnoDB 的行数据有多个版本，每个数据版本有自己的 row trx_id，每个事务或者语句有自己的一致性视图
    2)对于可重复读，查询只承认在事务启动前就已经提交完成的数据
    3)对于读提交，查询只承认在语句启动前就已经提交完成的数据
    4)当前读，总是读取已经提交完成的最新版本

### 09 普通索引和唯一索引 怎么选择？
    1）由于唯一索引用不上change buffer的优化机制，所以优先考虑非唯一索引
    2）两种机制在提升更新性能上的区别：
    2.1）change buffer：主要节省随机读磁盘的IO消耗，即更新数据前，先把数据所在的数据页从磁盘读入内存中，如果change buffer中存在则不用读磁盘。
    2.2）redo log：主要节省随机写磁盘的IO消耗，即多次 chang buffer 更新之后，一次redo log按顺序写入磁盘即可。

### 10 MySQL为什么有时候会选错索引？
    1）某次写入使用了Change Buffer机制，之后主机异常重启，是否会丢失 Change Buffer和数据？
    不会丢失。虽然只更新内存，但是在事务提交的时候，我们把Change Buffer的操作也记录到了redo log里，所以崩溃恢复的时候，Change Buffer也能找回来。
    2）索引统计方法 采样统计
    3）修复索引统计不准确的方法：analyze table table_name;
    4）索引选择异常怎么办？
        a)采用force index强行选择一个索引
        b)新建一个合适的索引，或者删掉错误的索引

### 11 怎么给字符串字段加索引？
    1）前缀索引优缺点：
    a)优点是节省空间
    b)缺点是：用不上覆盖索引；损失区分度，增了加查询扫描次数。

### 12 为什么我的MySQL会”抖“一下？
    1）脏页：内存数据页跟磁盘数据页不一致时，把内存页称为脏页
    2）redo log 设置太小的后果：
        磁盘压力很小，但是数据库出现间歇性的性能下降。
      涉及到的操作具体有：
      a）把相对应的内存页中的脏页持久化到磁盘，checkpoint往前推
      b）由于redo log还记录了undo的变化，undo log buffer也要持久化到undo log
      c）redo log还记录了change buffer的改变，那么还要把change buffer purge到idb，
      及持久化到磁盘。change buffer就失去了意义。

### 13 为什么表数据删掉一半，表文件大小不变？
    1）删除整个表的数据，所有的数据页都标记为可复用，但是磁盘上文件的大小不会变小。也就是说，delete命令不能回收表空间。
    2）analyze table t不是重建表，只是对表的索引信息做重新统计，没有修改数据。

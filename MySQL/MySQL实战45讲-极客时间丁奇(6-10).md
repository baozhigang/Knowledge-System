# 《MySQL实战45讲》— 极客时间丁奇(6-10) 专栏总结

### 06 全局锁和表锁
    1）MySQL的锁可分为：全局锁、表级锁、行锁
    2）全局表主要用在逻辑备份过程中，对于全部是InnoDB引擎的库，single-transaction 可重复读，对应用更友好
    3）表锁一般是数据库引擎不支持行锁的时候才会被用到
    4）在MySQL5.5版本中添加了MDL，对一个表增删改查的时候添加读锁（只读），修改表结构的时候，添加写锁
    5）MDL直到事务提交才释放

### 07 行锁功过
    1）两阶段锁协议：
        在InnoDB事务中，行锁是在需要的时候才加上的，而并不是不需要了就立刻释放。而是在整个事务完成后才释放
        所以在事务中，要把最容易造成冲突的，最容易影响并发的锁的放到最后
    2）死锁和死锁检测
        innodb_deadlock_detect  = on  主动开启死锁检测。死锁检测比较耗内存，所以要控制好并发

### 08 事务到底是隔离的还是不隔离的
    1)InnoDB 的行数据有多个版本，每个数据版本有自己的 row trx_id，每个事务或者语句有自己的一致性视图
    2)对于可重复读，查询只承认在事务启动前就已经提交完成的数据
    3)对于读提交，查询只承认在语句启动前就已经提交完成的数据
    4)当前读，总是读取已经提交完成的最新版本

### 09 普通索引和唯一索引 怎么选择？
    1）由于唯一索引用不上change buffer的优化机制，所以优先考虑非唯一索引
    2）两种机制在提升更新性能上的区别：
    2.1）change buffer：主要节省随机读磁盘的IO消耗，即更新数据前，先把数据所在的数据页从磁盘读入内存中，如果change buffer中存在则不用读磁盘。
    2.2）redo log：主要节省随机写磁盘的IO消耗，即多次 chang buffer 更新之后，一次redo log按顺序写入磁盘即可。

### 10 MySQL为什么有时候会选错索引？
    1）某次写入使用了Change Buffer机制，之后主机异常重启，是否会丢失 Change Buffer和数据？
    不会丢失。虽然只更新内存，但是在事务提交的时候，我们把Change Buffer的操作也记录到了redo log里，所以崩溃恢复的时候，Change Buffer也能找回来。
    2）索引统计方法 采样统计
    3）修复索引统计不准确的方法：analyze table table_name;
    4）索引选择异常怎么办？
        a)采用force index强行选择一个索引
        b)新建一个合适的索引，或者删掉错误的索引

### 11 怎么给字符串字段加索引？
    1）前缀索引优缺点：
    a)优点是节省空间
    b)缺点是：用不上覆盖索引；损失区分度，增了加查询扫描次数。

### 12 为什么我的MySQL会”抖“一下？
    1）脏页：内存数据页跟磁盘数据页不一致时，把内存页称为脏页
    2）redo log 设置太小的后果：
        磁盘压力很小，但是数据库出现间歇性的性能下降。
      涉及到的操作具体有：
      a）把相对应的内存页中的脏页持久化到磁盘，checkpoint往前推
      b）由于redo log还记录了undo的变化，undo log buffer也要持久化到undo log
      c）redo log还记录了change buffer的改变，那么还要把change buffer purge到idb，
      及持久化到磁盘。change buffer就失去了意义。

### 13 为什么表数据删掉一半，表文件大小不变？
    1）删除整个表的数据，所有的数据页都标记为可复用，但是磁盘上文件的大小不会变小。也就是说，delete命令不能回收表空间。
    2）analyze table t不是重建表，只是对表的索引信息做重新统计，没有修改数据。

### 14 count(*)这么慢，怎么办？
    1）mysql计数的方式：
    a)MyISAM引擎把一个表的总行数存储到磁盘上，执行count(*)时直接返回
    b)InnoDB引擎把数据一行一行从引擎里读出来，然后累计计数
    c)InnoDB不存储记录总数的原因：同一时刻的多个查询，用于多版本并发控制(MVCC)的原因
    2）关于查询
    a)MyISAM表虽然count(*)很快，但是不支持事务
    b)show table status 命令虽然返回很快，但是不准确
    c)InnoDB表直接count(*)会遍历全表，虽然结果准确，但是会导致性能问题
    3）计数统计方法
    a)用缓存系统保存计数，比如Redis，不精确
    b)可以数据库保存计数
    4)不同的count
    按效率排序：count(字段)<count(主键ID)<count(1) 大约等于 count(*)，推荐使用count(*)

### 16 "order by" 是怎么工作的？
    1）排序内存大小：sort_buffer_size 越小，需要分成的份数越多，number_of_tmp_files的值就越大
    2）SET max_length_for_sort_data=16，如果单行的长度超过这个值，MySQL就认为单行太大，要换一种算法
    3）全字段排序与RowID排序：
    a.MySQL担心排序内存太小时，为避免影响排序效率，才会采用RowID排序算法
    b.RowID排序会再回到原表去取数据
    c.MySQL认为内存足够大时，会优先选择全字段排序，把需要的字段都放到sort_buffer中
    4）覆盖索引是指，索引上的信息足够满足查询需求，不需要再回到主键索引上去取数据


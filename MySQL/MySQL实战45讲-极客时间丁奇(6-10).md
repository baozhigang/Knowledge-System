# 《MySQL实战45讲》— 极客时间丁奇(6-10) 专栏总结

### 06 全局锁和表锁
    1）MySQL的锁可分为：全局锁、表级锁、行锁
    2）全局表主要用在逻辑备份过程中，对于全部是InnoDB引擎的库，single-transaction 可重复读，对应用更友好
    3）表锁一般是数据库引擎不支持行锁的时候才会被用到
    4）在MySQL5.5版本中添加了MDL，对一个表增删改查的时候添加读锁（只读），修改表结构的时候，添加写锁
    5）MDL直到事务提交才释放

### 07 行锁功过
    1）两阶段锁协议：
        在InnoDB事务中，行锁是在需要的时候才加上的，而并不是不需要了就立刻释放。而是在整个事务完成后才释放
        所以在事务中，要把最容易造成冲突的，最容易影响并发的锁的放到最后
    2）死锁和死锁检测
        innodb_deadlock_detect  = on  主动开启死锁检测。死锁检测比较耗内存，所以要控制好并发

### 08 事务到底是隔离的还是不隔离的
    1)InnoDB 的行数据有多个版本，每个数据版本有自己的 row trx_id，每个事务或者语句有自己的一致性视图
    2)对于可重复读，查询只承认在事务启动前就已经提交完成的数据
    3)对于读提交，查询只承认在语句启动前就已经提交完成的数据
    4)当前读，总是读取已经提交完成的最新版本

### 09 普通索引和唯一索引 怎么选择？
    1）由于唯一索引用不上change buffer的优化机制，所以优先考虑非唯一索引
    2）两种机制在提升更新性能上的区别：
    2.1）change buffer：主要节省随机读磁盘的IO消耗，即更新数据前，先把数据所在的数据页从磁盘读入内存中，如果change buffer中存在则不用读磁盘。
    2.2）redo log：主要节省随机写磁盘的IO消耗，即多次 chang buffer 更新之后，一次redo log按顺序写入磁盘即可。

### 10 MySQL为什么有时候会选错索引？


# 《MySQL实战45讲》— 极客时间丁奇(1-5) 专栏总结

### 01 基础架构：一条SQL查询语句是如何执行的？
    1）大体来说，MySQL分为Server层和存储引擎层
    2）Server层包括连接器、查询缓存、分析器、优化器、执行器等。涵盖MySQL大多数核心服务功能
    3）存储引擎层负责数据的存储和提取。从5.5.5版本开始InnoDB变成默认存储引擎。

### 02 日志系统：一条SQL更新语句是如何执行的？
    1）redo log重做日志，InnoDB所特有的，容量是固定大小的，使用时会循环覆盖，具有crash-safe能力
    2）redo log是InnoDB引擎层所特有的日志(物理日志)，而Server层也有自己的日志:binlog 归档日志(逻辑日志)
    3）redo log是物理日志，记录的是在这个数据页上做了什么。binlog是逻辑日志，记录的是这个语句的原始逻辑。
    4）redo log是循环写的，固定空间会用完。binlog是追加的，不会覆盖之前的日志。
    5）两阶段事务提交，是为了使两个日志的状态保持一致

### 03 事务隔离：为什么你改了我还是看不见？
    1）事务是在引擎层实现的，MyISAM引擎不支持，InnoDB引擎层支持
    2）SQL的隔离级别：
        读未提交：别人改数据的事务尚未提交，我在我的事务中也能读到。
        读提交：别人改数据的事务尚已提交，我在我的事务中才能读到。
        可重复读：别人改数据的事务已经提交，我在我的事务中也不去读。
        串行化：我的事务尚未提交，别人就别想改数据。
        这4中隔离级别，并行性能依次降低，安全性依次提高。
    3）为什么尽量不用长事务？
        在事务提交前，数据库会保存所有的提交记录，占用大量的内存
        长事务还占用大量的锁资源
    4）问答题：如何避免长事务对业务的影响？
        首先，从应用开发端来看：
            确认是否使用了 set autocommit=0。这个确认工作可以在测试环境中开展，把 MySQL 的 general_log 开起来，然后随便跑一个业务逻辑，
        通过 general_log 的日志来确认。一般框架如果会设置这个值，也就会提供参数来控制行为，你的目标就是把它改成 1。
            确认是否有不必要的只读事务。有些框架会习惯不管什么语句先用 begin/commit 框起来。我见过有些是业务并没有这个需要，但是也把好几个
        select 语句放到了事务中。这种只读事务可以去掉。
            业务连接数据库的时候，根据业务本身的预估，通过 SET MAX_EXECUTION_TIME 命令，来控制每个语句执行的最长时间，避免单个语句意外执行太长时间。
        其次，从数据库端来看：
            监控 information_schema.Innodb_trx 表，设置长事务阈值，超过就报警 / 或者 kill；
            Percona 的 pt-kill 这个工具不错，推荐使用；
            在业务功能测试阶段要求输出所有的 general_log，分析日志行为提前发现问题；
            如果使用的是 MySQL 5.6 或者更新版本，把 innodb_undo_tablespaces 设置成 2（或更大的值）。如果真的出现大事务导致回滚段过大，
            这样设置后清理起来更方便。

### 04 深入浅出索引（上）
    1）索引的出现是为了提高数据查询的效率，就像数的目录
    2）索引常见模型
        哈希表适用于只有等值查询的场景
        有序数组在等值查询和范围查询场景中的性能都非常优秀 ，然后在更新数据时成本太高，适合静态存储
        N叉树在读写上的性能优点，以及适配磁盘的访问模式，被广泛应用在数据库引擎中
        索引不止存在内存中，还要写到磁盘上。N叉树相比二叉树，会尽量少的阅读磁盘，查询更少的数据块。
    3）InnoDB的索引模型
        使用了B+树索引模型，数据都存储在B+树中
        每一个索引在B+树中对应一棵二叉树
        主键索引又叫聚簇索引，其叶子节点存放的是page，整行的数据
        非主键索引又叫二级索引，叶子节点存放的是主键的值
        在实际应用中尽量使用主键索引，非主键索引会多扫描一棵二叉树
    4）索引的维护
        主键长度越小，普通索引的叶子节点就越小，普通索引占用的空间就越小
        从性能和存储空间方面考量，自增主键往往是更合理的选择
    5）重新创建索引
        alter table T engine=InnoDB

### 05 深入浅出索引（下）
    1）覆盖索引：覆盖索引可以减少树的搜索次数，显著提升查询性能
    2）最左前缀原则
    3）索引下推

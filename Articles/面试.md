# 面试

### 计算机网络基础

1.HTTP协议多看《极客时间》罗剑锋的专栏

2.进程、线程和协程对比
- 进程：进程是系统资源分配的最小单位，系统是由一个个进程组成。
一般情况下，包括文本区域，数据区域、堆栈。
文本区域存储处理器执行的代码。
数据区域存储变量和进程执行期间动态分配的内存。
堆栈区域存储着活动过程调用的指令和本地变量
- 线程：线程是CPU调度的最小单位。
线程属于进程，线程共享进程的内存地址空间。
线程几乎不占用系统资源的通信问题
- 协程：协程是属于线程的，是在线程里面跑的，因此又叫微线程。
协程的切换没有上下文消耗，是用户手动切换的。比较灵活，又叫用户空间线程

3.端口和服务
- 21 FTP 文件传输协议
- 22 SSH 用于远程登录
- 23 Telnet (远程登录)服务
- 25 SMTP 简单邮件传输协议
- 53 DNS域名服务器
- 80 HTTP协议
- 443 HTTPS
- 1080 sockets
- 3306 mysql
- 11211 memcached
- 6379 redis 

4.tcp三次握手
- 第一次握手：客户端发送一个TCP的SYN标志位置1的包，指明客户端打算连接的服务器的端口，以及初始序号X，保存在包头的序列号字段里
- 第二次握手：服务器发回确认包（ACK）应答。即SYN标志位和ACK标志位均为1。服务器端选择自己的ISN序列号，放在seq域里，同时将确认序号（Acknowledgement Number）设置为客户的ISN加1，即X+1。发送完毕后，服务器端进入SYN_RCVD状态
- 第三次握手：客户端再次发送确认包（ACK），SYN标志位为0，ACK标志位为1，并且把服务器发来ACK的序号字段+1，放在确定字段中发送给对方，并且在数据段放写ISN的+1
- 发送完毕后，客户端进入ESTABLISHED状态，当服务器端收到这个包时，也进入ESTABLISHED状态，TCP握手结束，TCP连接建立完成

5.在浏览器地址栏输入一个URL后回车
- 1)域名解析：浏览器的DNS缓存->操作系统的DNS缓存->hosts文件->迭代DNS解析请求，得到IP地址
- 2)发起TCP的3次握手
- 3)建立TCP连接后发起http请求
- 4)服务器响应http请求，浏览器得到html代码
- 5)浏览器解析html代码，并请求html代码中的资源（如js、css、图片等）
- 6)浏览器对页面进行渲染呈现给用户

6.TCP和UDP的比较
TCP传输控制协议，UDP用户数据协议，相同点是都属于tcp/ip协议的传输层
- 1）连接性：TCP是面向连接的协议，在收发数据前必须和对方建立可靠的连接，建立连接的3次握手、断开连接的4次挥手，为数据传输打下可靠基础。UDP是一个面向无连接的协议，数据传输前，源端和终端不建立连接，发送端尽可能快的将数据扔到网络上，接收端从消息队列中读取消息段
- 2）可靠性：TCP提供可靠交付的服务，传输过程中采用许多方法保证在连接上提供可靠的传输服务，如编号与确认、流量控制、计时器等，确保数据无差错，不丢失，不重复且按序到达。UDP使用尽可能最大努力交付，但不保证可靠交付
- 3）首部开销：TCP报文首部有20个字节，额外开销大。UDP报文首部只有8个字节，标题短，开销小。
- 4）传输方式：TCP协议面向字节流，将应用层报文看成一串无结构的字节流，分解为多个TCP报文段传输后，在目的站重新装配。UDP协议面向报文，不拆分应用层报文，只保留报文边界，一次发送一个报文，接收方去除报文首部后，原封不动将报文交给上层应用
- 5）连接对象个数：UDP支持一对一、一对多、多对一和多对多的交互通信。TCP只能一对一通信。
- 6）使用场景：TCP适合对传输效率要求低，但准确率要求高的应用场景，比如万维网(HTTP)、文件传输(FTP)、电子邮件(SMTP)等。UDP适用于对传输效率要求高，但准确率要求低的应用场景，比如域名转换(DNS)、远程文件服务器(NFS) IP电话、视频会议、直播等。

### 数据结构与算法
##### 《极客时间》算法面试通过40讲，不断的去练习和总结
考察点：常用的几个算法，时间复杂度和空间复杂度分析，和一些简单的算法题

1.快排
- 平均时间复杂度O(nlog2n)，最差O(n2)，最好O(nlog2n)。
- 空间复杂度log2n
- 不稳定

2.冒泡排序
- 平均时间复杂度O(n2)，最差O(n2)，最好O(n)。
- 空间复杂度1，不占用额外空间
- 稳定


### 数据库

#### mysql

1.mysql事务隔离级别
- 读未提交：最低的隔离级别，可能会导致脏读、幻读、或不可重复读
- 读已提交：允许读取并发事务已提交的数据，可防止脏读，不能防止幻读或者可重复读
- 可重复读：对同一字段多次读取结果是一致的。可以阻止脏读和不可重复读，但幻读仍有可能发生
- 可串行化：最高隔离级别。事务排序逐个执行不冲突

2.脏读、不可重复读、幻读举例
- 事务A查询一条数据，事务B插入数据未提交，事务A再查询数变了，读到了脏数据，叫脏读
- 事务A查询一条数据，事务B插入一条数据然后提交，事务A再查询，结果变了，叫不可重复读
- 事务A查询一条数据，事务B插入一条数据然后提交，事务A再查询，结果没变，事务A也插入和B一样的一条数据，插入不成功，好像出现幻觉，叫幻读。

3.MySQL存储引擎MyISAM与InnoDB区别
- 1）存储结构
-- myisam每张表被存储在3个文件中，frm-表格定义、MYD(MYData)-数据文件、MYI(MYIndex)-索引文件
-- innodb所有表存储在同一数据文件，存储空间仅受限于操作内存大小，一般为2GB
- 2）文件格式
-- myisam 数据和索引是分开存储的，数据.MYD, 索引.MYI
-- innodb 数据和索引是集中存储的，文件.ibd
- 3）外键
-- myisam 不支持。innodb 支持。
- 4）事务
-- myisam 不支持。innodb 支持。
- 5）锁支持
-- myisam 表级锁。innodb 行级锁，抗并发能力高。

4.事务四大特性
- 原子性、一致性、隔离性、持久性

5.死锁
- 概念：两个或者多个事务在同一资源上相互占用，并请求锁定对方资源，导致恶性循环
- 如何解决？对于容易产生死锁的业务，提升锁的颗粒度，使用表级别锁来减少死锁

6.mysql优化
- 6.1 优化SQL
-- 避免在字段开头使用模糊查询
-- 尽量不使用in和not in
-- 尽量不使用or, 使用union 代替
-- 尽量不判断是否为null
-- 避免使用select *
-- 多表关联查询时，小表在前，大表在后
-- 调整where的连接顺序，把过滤数据最多的条件放在前面
- 6.2 explain 关键字分析
-- key字段，显示使用了哪些索引
-- rows估算要查询的行数
-- filtered查询行数与总行数的比值
- 6.3 慢查询
-- set global slow_query_log = 1

7.主从原理和配置
- 1）binlog线程——记录下所有改变了数据库数据的语句，放进master上的binlog中
- 2）io线程——在使用start slave 之后，负责从master上拉取 binlog 内容，放进自己的relay log中；
- 3）sql执行线程——执行relay log中的语句

8.添加索引原则
- 1）选择唯一性索引(比如学号是唯一的，姓名不是)
- 2）为经常需要排序 order by 分组group by 、distinct 建立索引
- 3）经常作为查询条件的字段添加索引
- 4）限制索引的数量。索引占用磁盘空间，添加和更新麻烦
- 5）联合索引遵循最左前缀原则
- 6）索引应添加在小字段上，对大的文本字段，甚至超长字段不要添加索引

9.索引的数据结构和算法原理
- https://www.jianshu.com/p/1775b4ff123a  多看两遍不难理解

10.数据库索引数据结构
常见的索引数据结构有三种：哈希表、有序数组和搜索树。
- 哈希表适用于只有等值查询的场景，不适合范围查询。比如memcached及一些NoSQL引擎。
- 有序数据适用于等值查询和范围查询，但插入数据的时候成本太高，只适用于静态存储引擎。比如存储2017年某个城市的人口信息。
- 搜索树最常用的就是B+树，也就是InnoDB的索引结构。B+数能够很好地配合磁盘的读写特性，减少单次查询的磁盘访问次数。

11.唯一索引和主键索引的区别
> 唯一索引不允许两行具有相同的索引值。
> 主键索引是唯一索引的特殊类型，表的主键通常由一列或多列组合，其值用来标识表中的每一行。

区别：
- 主键创建后一定包含一个唯一性索引，唯一性索引并不一定就是主键。
- 唯一性索引列允许空值，而主键列不允许为空值。
- 主键可以被其他表引用为外键，而唯一索引不能。
- 一个表最多只能创建一个主键，但可以创建多个唯一索引。

12.谈谈MySQL索引的数据结构
一）B+树结构
- 1）B+树是由二叉树演化而来
- 2）不管是内存中的数据还是磁盘中的数据，操作系统都是按页来读取的，一次读取一页的数据。m叉数中的m值是根据页的大小事先计算好的。
- 3）每个节点中子节点的个数不能超过m,也不能小于m/2
- 4）根节点的子节点个数可以不超过 m/2，这是一个例外
- 5）m叉数只存储索引，不存储真正的数据
- 6）通过链表将叶子节点串联在一起，方便按区间查找
- 7）一般根节点会存储在内存中，其他节点存储在磁盘中
- 8）B树是低级版的B+树，区别在于B树的节点存储数据，而不是索引。叶子节点也不需要链表来串联。
二）聚簇索引(主键索引)和非聚簇索引(二级索引)
- 1）非聚簇索引的叶子节点存储的是主键的索引，聚簇索引的叶子节点存储的是索引值和行数据

13.跳表
- 1）跳表是可以实现二分查找的有序链表
- 2）每个元素插入时随机生成它的level
- 3）最底层包含所有的元素
- 4）如果一个元素出现在level(x)，那么它肯定出现在x以下的level中
- 5) 每个索引结点包含两个指针，一个向下，一个向右
- 6）跳表查询、插入、删除的时间复杂度都是O(logN),与平衡二叉树接近
- 7）为什么Redis选择使用跳表而不是红黑树来实现有序集合？
    按范围区间查找元素时红黑树的效率没有跳表高。
- 8）参考文章看 [这里](https://www.jianshu.com/p/9d8296562806)
#### Redis

1.用作消息队列优缺点
- 优点：异步、削峰，提高并发
- 缺点：当处理数据失败，或者服务器宕机，容易造成数据丢失
- 怎么解决？解决：数据处理失败则重新push到新的队列中，定时脚本处理

2.redis优缺点
- 优点：
- 1）读写性能优异，读11万次/秒，写8.1万次/秒
- 2）支持数据持久化，AOF和RDB两种方式
- 3）支持事务
- 4）数据结构丰富，value支持string、hash、set、zset、list等数据结构
- 5）支持主从复制
- 缺点
- 1）数据容量有限，只适合较小数据量的高性能操作
- 2）不具备容错和数据恢复功能
- 3）较难支持在线扩容

3.redis持久化
- 1）RDB：按照一定时间将内存的数据以快照的形式保存到磁盘当中，是全量备份。RDB持久化，安全性较差，它是正常时期数据备份及 master-slave数据同步的最佳手段，文件尺寸较小，恢复数度较快。
- 2）AOF：将redis执行的每次写命令都记录到日志当中。AOF更安全，可将数据及时同步到文件中，但需要较多的磁盘IO，AOF文件尺寸较大，文件内容恢复相对较慢， 也更完整。

4.缓存雪崩、击穿、穿透的问题
[看这里](https://baozhigang.github.io/2021/11/02/redis_%E7%BC%93%E5%AD%98%E9%9B%AA%E5%B4%A9/#more)

5.缓存和数据库双写一致性问题
[看这里](https://baozhigang.github.io/2021/11/03/redis_%E7%BC%93%E5%AD%98%E5%92%8C%E6%95%B0%E6%8D%AE%E5%BA%93%E5%8F%8C%E5%86%99%E4%B8%80%E8%87%B4%E6%80%A7%E9%97%AE%E9%A2%98/#more)

6.redis和memcache区别
- 存储方式：
    memcache 把数据全部存在内存之中，断电后会挂掉，数据不能超过内存大小
    redis有部份数据存在硬盘上，这样能保证数据的持久性。
- 数据支持类型：
   redis在数据支持上要比memcache多的多。
   redis数据类型：String、Hash、List、Set、SortedSet
   memcache支持简单的数据类型K/V键值对缓存，需要客户端自己处理复杂的对象
- 应用范围
    memcache只能当做缓存，redis的内容是可以落地的，可以作为缓存，同时可以设置master-slave主从复制
- 数据一致性不同
   Memcached提供了cas命令(Check-And-Set)，可以保证多个并发访问操作同一份数据的一致性问题。
   Redis没有提供cas 命令，并不能保证这点，不过Redis提供了事务的功能，可以保证一串命令的原子性。
- 性能对比
    Redis只使用单核，而Memcached可以使用多核，所以平均每一个核上Redis在存储小数据时比Memcached性能更高。而在100k以上的数据中，Memcached性能要高于Redis。
- 内存管理
    Memcached使用预分配的内存池的方式，使用slab和大小不同的chunk来管理内存，内存池的方式可以省去申请/释放内存的开销，并且能减小内存碎片产生，但这种方式也会带来一定程度上的空间浪费。
    Redis使用现场申请内存的方式来存储数据，并且很少使用free-list等方式来优化内存分配，会在一定程度上存在内存碎片。

### 框架
1.restful API

### Linux常用命令

- find ./ -name "file.php" 查找文件
- 压缩 tar -czvf abc.tar.gz abc 解压 tar -xzvf abc.tar.gz
- df -h 显示磁盘空间。du -h 显示目录和文件使用的磁盘空间
- ln -sv source.log link.log 建软链接 ln -v source.log link1.log 建硬链接
- ps -ef | grep nginx  查找指定进程
- cat test1.txt | grep -f key.log  从文件中读取指定文字
- wc text.txt  查找文件中行数、单词数、字节数、文件名
- ps -ef 显示当前所有进程环境变量与进程之间的关系
- top  显示当前系统正在执行的进程的相关信息
- kill -9 强制杀死进程
- free 显示系统内存的使用情况
- netstat -tunlp | grep 端口号  查看端口号占用情况

### PHP

1.PHP垃圾回收机制
- 以php的引用计数机制为基础
- 同时使用根缓冲区机制，当php发现有存在循环引用的zval时，就会把其投入到根缓冲区，当根缓冲区达到配置文件中的指定数量后，就会进行垃圾回收，以此解决循环引用导致的内存泄漏问题

2.常见的数组函数、字符串函数、文件函数

3.接口和抽象类的区别
- 对接口的使用方式是通过关键字implements来实现的，而对于抽象类的操作是使用类继承的关键字extends实现的，使用时要注意。
- 接口没有数据成员，但是抽象类有数据成员，抽象类可以实现数据的封装。
- 接口没有构造函数，抽象类可以有构造函数。
- 接口的方法都是public类型，而抽象类中的方法可以使用private、protected或public来修饰。
- 一个类可以同时实现多个接口，但是只能实现一个抽象类。

4.PHP新特性
- PHP7
- 1)标量类型声明
- 2）返回值类型声明
- 3）null合并运算符??
- 4)太空船比较符
- 5）新增整数除法函数 intdiv()

- PHP8
- 1)联合类型
- 2)非捕获 catches
- 3)参数列表中的尾部逗号

5.PSR代码规范

### 消息队列
1.解决消息积压的方法
- 优化发送端，增加批量和线程并发两种处理方式
- 临时扩容，增加消费端，用硬件提升消速度费
- 服务降级，关闭一些非核心业务，减少消息生产
- 通过日志分析查找原因，上游生产者是否异常生产大量数据，中游消息队列存储层是否出现问题，下游消费速度是否变慢，看哪里出现问题

### 设计模式

1.常见的设计模式有哪些？使用场景分别是什么？

2.手写单例、工厂等简单的设计模式

### git

1.常用命令

### Nginx

没研究过，后续研究框架的时候再去学习

### 面试关键
1.计算机系统知识、算法和mysql这三块，决定了上限。也是应该多准备的地方。
2.好好准备和简单准备，效果能差3K。
3.刷面试题  https://www.nowcoder.com/discuss/experience?tagId=649
4.博客和github要积累起来
# 《计算机系统基础》— 南京大学

### 第1周 计算机系统概述 

### 第2周 数据的表示和存储 

#### 第1讲 数制和编码
1.机器级数据分两大类
- 数值数据：无符号整数、带符号整数、浮点数（实数）
- 非数值数据： 逻辑数（包括位串）、西文字符和汉字     

2.计算机内部所有信息都用二进制（0和1）进行编码
3.用二进制编码原因：
- 制造二个稳定态的物理器件容易（电位高/低、脉冲有/无、正/负极）
- 二进制编码编码、计数、运算规则简单
- 正好与逻辑命题真/假对应，便于逻辑运算
- 可方便的用逻辑电路实现算数运算

4.真值和机器数
- 机器数：用0和1编码的计算机内部0/1序列
- 真值： 真正的值，即现实中带正负号的数

5.数值数据表示的三要素
- 进位计数制
- 定、浮点表示
- 如何用二进制编码 

6.进位计数制
- 十进制、二进制、十六进制等相互转化    

7.定、浮点表示（解决小数点问题）
- 定点整数、定点小数
- 浮点数（可用一个定点小数和定点整数来表示）

8.定点数的编码（解决正负号问题）
-  原码、补码、移码、反码（反码很少用）

9.有了二进制，为什么要八进制和十六进制 ？
-- 便于阅读和书写，相比二进制可缩短长度

10.二进制后缀B，如： 1010B
   十六进制后缀H，或者前缀0x 如：0xac45108d、ac45108dH 

11.十进制和R进制数之间的转换   
12.现实中的精确值可能在计算机当中无法精确表示 如：10.63 

13.计算机中只有1和0，数值数据中的小数点怎么表示呢？
-- 计算机只能通过约定小数点的位置来表示
-- 小数点位置约定在固定位置的数称为定点数
-- 小数点位置约定为可浮动的数称为浮点数 

#### 第2讲 定点数的编码表示
1.原码表示
- 正号用0表示，负号用1表示，数值部分不变，如：
-- 7 -> 0111, -7 -> 1111 (即最前面一位表示正负号) 
- 容易理解，但是优缺点：
-- 0的表示不唯一，不利于程序员编程
-- 加减运算方式不统一 ？
-- 需额外对负号进行处理，不利于硬件设计
-- 特别当a < b时，实现a-b比较困难 ？
- 从50年代开始，整数都采用补码表示，但是浮点数的尾数用原码定点小数表示

2.移码表示
- 将每一个数值加上一个偏置常数
- 通常，当编码位数为n时，取2的n或者n-1次方。如：
-- 1000B（补码表示，最高位为负权） -8（+8）-> 0000B （移码表示）
-- 1001B（补码表示，最高位为负权） -7(+8) -> 0001B (移码表示) 

3.补码（模运算）
- 时钟是一种模12系统，-4的模12补码等于8 
- 一个负数的补码等于模减去该负数的绝对值
- 对于确定的模，如模12系统，10-4等价于10+8=18%12 = 6 
- 补码定义：[X]补 = 2的n次方 + X （-2n<=X<2n, mod2n）
-- 正数，符号位为0，数值部分不变
-- 负数，符号位为1，数值部分”数值取反，末尾加1“
- 变形补码，双符号，用于存放可能溢出的中间结果 

#### 第3讲 C语言中的整数
1.无符号整数
- 机器中字的位排列有两种方式：
-- LSB最低有效位  MSB最高有效位 

2.带符号整数
用MSB表示数符（0--正数，1--负数）

#### 第4讲 浮点数的编码表示
1.浮点数的表示范围
- 第0位数符S 
- 第1~8位为8位移码，表示阶码E(偏置常数为128)
- 第9~31位为24位二进制原码小数表示的位数M 
- 机器0：尾数为0或者落在下溢区中的数 
- 浮点数范围比定点数大，但数的个数没变多，故数之间更稀疏，且不均匀 

2.IEEE754标准 
- 规格化数： +/-1.xxxxxxx(two) * 2(ex) 
- SP规格化阶码范围 0000 0001(-126) ~ 1111 1110(127) 
- 偏置常数 单精度127， 双精度1023
- SP： (-1)s * (1+significand) * 2(ex-127)
- DP： (-1)s * (1+significand) * 2(ex-1023) 

#### 第5讲 非数值数据的编码
1.逻辑数据的编码表示
2.西文字符的编码表示
- 所有字符不超过256个，用7或者8位二进制位可表示
- 表示：常用编码为7位ASCII码  
 
3.汉字及国际字符的编码

#### 第6讲 数据的宽度和存储 
1.数据的基本宽度
- 数据通路指CPU内部数据流经的路径以及路径上的部件，主要是CPU内部进行数据运算、存储和传输的部件，这些部件的宽度基本上要一致，才能相互匹配。
- 字和字长的概念不同：
-- 字长是数据通路的宽度
-- 字长等于CPU内部总线的宽度、运算器的位数、通用寄存器的宽度
-- 字表示被处理信息的单位，用来度量数据类型的宽度
-- 字和字长的宽度可以一样，也可以不同

2.数据量的基本单位
- 存储二进制信息时的度量单位要比字节或字大太多
- 容量经常使用的单位有：
-- 千字节KB 1KB=2(10次)字节=1024B 兆字节MB 千兆字节GB 兆兆字节TB
- 通信中的宽带使用的单位有：
-- 千比特/秒 Kb/s 1Kbps=10(3次)b/s 兆比特/秒Mb/s  

#### 第7讲 数据存储时的字节排列

### 第3周 运算电路基础

#### 第1讲 数字逻辑电路基础
1.布尔代数
- 0和1分别代表假和真，逻辑运算：与、或、非

2.一位逻辑门电路
- F=A·B  F=A+B F=ˉA 

3.组合逻辑部件
- 根据电路是否具有存储功能，将逻辑电路分为两种类型
-- 组合逻辑电路(没存储功能)   -- 时序逻辑电路(有存储功能)
- 多路选择器
- 一位加法器 
- n位加法器可用n个全加器来实现 
-- 加法由逻辑部件实现，而其他所有算数运算部件都基于加法器和逻辑运算实现，因此，所有算数运算都是基于0和1以及逻辑运算来实现的 
- 算数逻辑部件（ALU）
-- 无符号整数加减，带符号整数加减，与或非异或等逻辑运算
-- 核心电路是带标志的加法器

4.认知计算机中最基本的部件
-- CPU：中央处理器
-- PC：程序计数器
-- MAR：存储器地址寄存器
-- ALU：算数逻辑部件
-- IR： 指令寄存器
-- MDR： 存储器数据寄存器
-- GPRs: 通用寄存器组(由若干通用寄存器组成)  

#### 第2讲 从C表达式到逻辑门
1.c语言中的数据类型
- 基本数据类型：
-- 无符号数、带符号整数、浮点数、位串、字符
- 基本运算类型
-- 算数、按位、逻辑、移位、扩展和截断 

2.计算机如何实现高级语言程序中的运算？
- 将各类表达式编译为指令序列
- 移位器和整数加减运算都是由逻辑门电路构成的

3.数据的运算
- 高级语言程序中涉及的运算，转为指令集中涉及到的运算，转为指令中的运算操作在运算电路中进行 

#### 第3讲 c语言中的各类运算
#### 第4讲 整数的加减运算
1.指针、地址等通常被说明为无符号整数，因而在进行指针或地址运算时，需要进行无符号整数的加减运算
2.整数加减运算部件，基于带标志加法器实现 
3.所有运算电路的核心
- 计算机中所有运算都基于加法器实现 
- 加法器不知道所运算的是带符号数还是无符号数
- 加法器不判定对错，总是取低n位为结果，并生成标志信息  

4.条件标志在运算电路中产生，被记录到专门的寄存器中 
5.运算符号：
- 当Sub为1时做减法，当Sub为0时做加法 
- ZF：零标志，SF：符号标志，OF：溢出标志，CF：进/借位标志 
- 如何得到各个标志位？
-- OF:若A与B同号但与Sum不同号，则为1(溢出)，否则为0
-- SF：sum符号 
-- ZF：若sum为0，则1，否则0 
-- CF：Count异或Sub 
- 做加法时主要判断是否溢出：
-- 无符号加溢出条件：CF=1,带符号加溢出条件：OF=1 

6.无符号加法公式：
- 当x+y<2的n次方时，result = x+y;
- 当x+y>=2的n次方，小于2的n+1次方时，result = x+y-2的n次方

7.带符号加法公式：
- 当x+y>=2的n-1次方时，result = x+y-2的n次方 （正溢出）
- 当x+y>= -2的n-1次方，且x+y< 2的n-1次方时，result = x+y （正常）
- 当x+y< -2的n-1次方时，result = x+y+2的n次方 （负溢出）

### 第4周 乘除运算加浮点运算 

#### 第1讲 整数乘法运算

1.整数乘法运算
- 通常，高级语言中两个n位整数相乘得到的结果通常也是一个n位整数，即结果只取2n位乘积中的低n位
- 在计算机内部，一定有x的平方 >=0 吗？若x是带符号整数则不一定。 
- 如n=4 位时，5*5 = -7 < 0
- int x,y,z; z=x*y; 当x=0或者x==z/y 时z是正确的值 

2.X*Y的高n位可以用来判断溢出，规则如下：
- 无符号：若高n位全0，则不溢出，否则溢出
- 带符号：若高n位全0或者全1，且等于低n位的最高位，则不溢出 

3.乘法指令不生成溢出标志，编译器可以使用2n位乘积来判断是否溢出 
4.编译器在处理变量与常数相乘时，往往以移位、加法和减法的组合运算来代替乘法运算 

#### 第2讲 整数除法运算
1.对于带符号整数来说，n位整数除以n位整数，除-2的n-1 /-1 = 2的n-1 发生溢出外，其余情况都不会发生溢出。
2.不能整除需要四舍五入时，通常朝0的方向舍入。如7/2=3, -7/2=-3

#### 第3讲 浮点数运算
1.IEEE754标准规定的五种异常情况
- 无效运算 
-- 运算时有一个数是非有限数，如 +/-/*// 无穷 
-- 结果无效，如：源操作数是NaN、0/0 
- 除以0，即无穷大 
- 数太大（阶上溢），对于SP，指数大于127
- 数太小（阶下溢），对于SP，指数小于-126
- 结果不精确（舍入时引起），例如1/3、1/10 不能精确表示成浮点数 

2.浮点数除0的问题
- 整数除0会发生异常
- 浮点数除0，是无穷大，浮点数有全1序列，表示无穷大，所以不会发生异常 

3.c语言中的浮点数类型
- C语言中有float和double类型，分别对应IEEE754中的单精度浮点数和双精度浮点数格式
- 从int转float，不会发生溢出，但可能会有数据的舍入
- 从int或float转换为double时，因为double的有效位数更多，故能保留其精确值 
- 从double转换为float或者int时，可能发生溢出，因为有效位数减少，故可能被舍入
- 从float或者double转换为int时，因为int没有小数部分，所以数据可能会向0的方向被截断 

4.IEEE754大范围和精度
- 单精度浮点数范围最大 +1.11*2的127次方，约3.4*10的38次方 
- 双精度浮点数double, 约+1.8*10的308次方 
- 浮点数不符合加法的结合律，会出现大数吃小数的问题 

5.浮点数的精度问题
- 在不同数据类型之间转换时，往往隐藏着一些不容易被觉察的错误 
- 用float表示在计算速度上更慢，必须先把计数值转换为IEEE754格式浮点数，然后在对两个IEEE754格式的数相乘，故采用float比直接将两个二进制数相乘要慢  

### 第5周 IA-32指令系统

#### 第1讲 程序转换概述 
1.指令
- 计算机的指令有微指令、机器指令和伪(宏)指令之分
- 机器指令位于硬件和软件的交界面
- 微指令是微程序级指令，属于硬件范畴
- 伪指令是若干机器指令组成的指令序列，属于软件范畴 
- 汇编指令是机器指令的汇编表示形式，即符号表示
- 机器指令和汇编指令一一对应，他们都与具体机器结构有关，都属于机器级指令 

2.机器指令
- 机器指令是一个0/1序列，由若干字段组成，包括：操作码、寻址方式、寄存器编号、立即数（位移量）
- 汇编指令是机器指令的符号表示

3.指令集体系结构 Instruction Set Architecture 
- ISA是一种规约，它规定了如何使用硬
-- 可执行的指令的集合，包括指令格式、操作种类以及每种操作对应的操作数的相应规定
-- 指令可以规定的操作数类型
-- 操作数所能存放的寄存器组的结构，包括每个寄存器的名称、编号、长度和用途 
-- 操作数所能存放的存储空间的大小和编址方式
-- 操作数在存储空间存放时按照大端还是小端方式存放
-- 指令获取操作数的方式，即寻址方式
-- 指令执行过程中的控制方式，包括程序计数器、条件码定义等
- ISA在计算机系统中是必不可少的一个抽象层，没有他，软件无法使用计算机硬件

4.ISA和计算机组成之间的关系
- 不同ISA规定的指令集不同，如IA-32，ARM等 
- 计算机组成必须实现ISA规定的功能，如提供GPR、运算电路等 
- ISA是计算机组成的一种抽象 

#### 第2讲 IA-32指令系统
1.IA-32/x64指令系统概述
- x86是intel开发的一类处理器体系结构的泛称
- Intel把32位x86架构的名称x86-32该名称位IA-32 (I:Intel, A:Architecture) 
- 由AMD首先提出了一个兼容IA-32指令集的64位版本
- IA-32体系结构包括：8个GPR(通用寄存器)、一个EFLAGs(标志寄存器)、PC为EIP、可寻址空间为4GB、指令格式变长、操作码变长、指令由若干字段（OP、Mod、SIB等）组成
- IA-32的标志寄存器：
-- 6个条件标志：OF、SF、ZF、CF、AF(辅助进位标志)、PF(奇偶标志) 
-- 3个控制标志：DF(方向标志)、IF(中断允许标志)、TF(陷阱标志) 


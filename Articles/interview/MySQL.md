### 1.mysql事务隔离级别
- 读未提交：最低的隔离级别，可能会导致脏读、幻读、或不可重复读
- 读已提交：允许读取并发事务已提交的数据，可防止脏读，不能防止幻读或者可重复读
- 可重复读：对同一字段多次读取结果是一致的。可以阻止脏读和不可重复读，但幻读仍有可能发生
- 可串行化：最高隔离级别。事务排序逐个执行不冲突

### 2.脏读、不可重复读、幻读举例
- 事务A查询一条数据，事务B插入数据未提交，事务A再查询数变了，读到了脏数据，叫脏读
- 事务A查询一条数据，事务B插入一条数据然后提交，事务A再查询，结果变了，叫不可重复读
- 事务A查询一条数据，事务B插入一条数据然后提交，事务A再查询，结果没变，事务A也插入和B一样的一条数据，插入不成功，好像出现幻觉，叫幻读。

### 3.MySQL存储引擎MyISAM与InnoDB区别
- 1）存储结构
-- myisam每张表被存储在3个文件中，frm-表格定义、MYD(MYData)-数据文件、MYI(MYIndex)-索引文件
-- innodb所有表存储在同一数据文件，存储空间仅受限于操作内存大小，一般为2GB
- 2）文件格式
-- myisam 数据和索引是分开存储的，数据.MYD, 索引.MYI
-- innodb 数据和索引是集中存储的，文件.ibd
- 3）外键
-- myisam 不支持。innodb 支持。
- 4）事务
-- myisam 不支持。innodb 支持。
- 5）锁支持
-- myisam 表级锁。innodb 行级锁，抗并发能力高。

### 4.事务四大特性
- 原子性、一致性、隔离性、持久性

### 5.死锁
- 概念：两个或者多个事务在同一资源上相互占用，并请求锁定对方资源，导致恶性循环
- 如何解决？对于容易产生死锁的业务，提升锁的颗粒度，使用表级别锁来减少死锁

### 6.mysql优化
- 6.1 优化SQL
-- 避免在字段开头使用模糊查询
-- 尽量不使用in和not in
-- 尽量不使用or, 使用union 代替
-- 尽量不判断是否为null
-- 避免使用select *
-- 多表关联查询时，小表在前，大表在后
-- 调整where的连接顺序，把过滤数据最多的条件放在前面
- 6.2 explain 关键字分析
-- key字段，显示使用了哪些索引
-- rows估算要查询的行数
-- filtered查询行数与总行数的比值
- 6.3 慢查询
-- set global slow_query_log = 1

### 7.主从原理和配置
- 1）binlog线程——记录下所有改变了数据库数据的语句，放进master上的binlog中
- 2）io线程——在使用start slave 之后，负责从master上拉取 binlog 内容，放进自己的relay log中；
- 3）sql执行线程——执行relay log中的语句

### 8.添加索引原则
- 1）选择唯一性索引(比如学号是唯一的，姓名不是)
- 2）为经常需要排序 order by 分组group by 、distinct 建立索引
- 3）经常作为查询条件的字段添加索引
- 4）限制索引的数量。索引占用磁盘空间，添加和更新麻烦
- 5）联合索引遵循最左前缀原则
- 6）索引应添加在小字段上，对大的文本字段，甚至超长字段不要添加索引

### 9.索引的数据结构和算法原理
- https://www.jianshu.com/p/1775b4ff123a  多看两遍不难理解

### 10.数据库索引数据结构
常见的索引数据结构有三种：哈希表、有序数组和搜索树。
- 哈希表适用于只有等值查询的场景，不适合范围查询。比如memcached及一些NoSQL引擎。
- 有序数据适用于等值查询和范围查询，但插入数据的时候成本太高，只适用于静态存储引擎。比如存储2017年某个城市的人口信息。
- 搜索树最常用的就是B+树，也就是InnoDB的索引结构。B+数能够很好地配合磁盘的读写特性，减少单次查询的磁盘访问次数。

### 11.唯一索引和主键索引的区别
> 唯一索引不允许两行具有相同的索引值。
> 主键索引是唯一索引的特殊类型，表的主键通常由一列或多列组合，其值用来标识表中的每一行。

区别：
- 主键创建后一定包含一个唯一性索引，唯一性索引并不一定就是主键。
- 唯一性索引列允许空值，而主键列不允许为空值。
- 主键可以被其他表引用为外键，而唯一索引不能。
- 一个表最多只能创建一个主键，但可以创建多个唯一索引。

### 12.谈谈MySQL索引的数据结构
一）B+树结构
- 1）B+树是由二叉树演化而来
- 2）不管是内存中的数据还是磁盘中的数据，操作系统都是按页来读取的，一次读取一页的数据。m叉数中的m值是根据页的大小事先计算好的。
- 3）每个节点中子节点的个数不能超过m,也不能小于m/2
- 4）根节点的子节点个数可以不超过 m/2，这是一个例外
- 5）m叉数只存储索引，不存储真正的数据
- 6）通过链表将叶子节点串联在一起，方便按区间查找
- 7）一般根节点会存储在内存中，其他节点存储在磁盘中
- 8）B树是低级版的B+树，区别在于B树的节点存储数据，而不是索引。叶子节点也不需要链表来串联。
二）聚簇索引(主键索引)和非聚簇索引(二级索引)
- 1）非聚簇索引的叶子节点存储的是主键的索引，聚簇索引的叶子节点存储的是索引值和行数据

### 13.谈谈乐观锁和悲观锁
1. 乐观锁
顾名思义就是操作的时候很乐观，认为对同一数据的并发操作属于小概率事件，不用每次都对数据上锁，也就是不采用数据库自身的锁机制，而是通过程序来实现。在程序上通常采用版本号机制或者时间戳机制来实现。
- 版本号机制
-- 在表中设计一个版本字段 version，第一次读的时候，会获取 version 字段的取值。然后对数据进行更新或删除操作时，会执行 UPDATE ... SET version=version+1 WHERE version=version AND id=...  此时如果已经有事务对这条数据进行了更改，修改就不会成功.
- 时间戳机制
-- 和版本号机制类似，数据库添加字段存储时间戳
2. 悲观锁
总是假设最坏的情况，每次取数据时都认为其他线程会修改，所以会加锁。一旦加锁，不同线程同时执行时，只能有一个线程执行，其他线程在等待，直到锁被释放。
3. 适用场景
- 乐观锁适合读操作多的场景，相对来说写的操作比较少。它的优点在于程序实现，不存在死锁问题。
- 悲观锁适合写操作多的场景，因为写操作具有排他性。

### 14.varchar 能存放多少字符？
1. varchar类型
- varchar (N)：中的N指的是字符的长度，即：该字段最多能存储多少个字符(characters)，不是字节数。不管是一个中英文字符或者数字、或者一个汉字，都当做一个字符。
- varchar 最多能存储 65535 个字节的数据。
-- 65535 = 所有字段的长度 + 变长字符的长度标识 + NULL标识位
-- 变长字符的长度标识：用1到2个字节表示实际长度（长度 >255 时,需要2个字节； <255 时，需要1个字节）
-- NULL标识位：varchar字段定义中带有 default null 允许列空,则需要 1 bit 来标识，每 8 个bits的标识组成一个字段。一张表中存在N个varchar字段，那么需要（N+7）/8 （取整）bytes存储所有的NULL标识位。
- MySQL本身对所有列的合并大小施加了 65535 字节的行大小限制。

2. varchar长度的限制
- 字符类型若为gbk，每个字符最多占2个字节，最大长度不能超过32766; 即(65535-2)/2。
- 字符类型若为utf8，每个字符最多占3个字节，最大长度不能超过21845。即(65535-2)/3。
- 字符类型若为utf8mb4，每个字符最多占4个字节，最大长度不能超过16283。即(65535-2)/4。
- 若定义的时候超过上述限制，则varchar字段会被强行转为text类型，并产生warning。

